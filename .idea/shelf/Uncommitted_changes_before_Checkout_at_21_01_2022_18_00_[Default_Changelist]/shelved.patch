Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom Game_Alex import menu_forrest_game\r\nfrom Game_Mary import main_gameplay_snow\r\nfrom final_screen import final_game_screen\r\nfrom main_functions import *\r\n\r\nsize = WIDTH, HEIGHT = 645, 400\r\nscreen = pygame.display.set_mode(size)\r\npygame.mouse.set_visible(True)\r\nclock = pygame.time.Clock()\r\n\r\nall_sprites = pygame.sprite.Group()\r\nhouses = pygame.sprite.Group()\r\nstar_group = pygame.sprite.Group()\r\nmenu_group = pygame.sprite.Group()\r\n\r\nback_img = load_image('snow/back_img.png', color_key=-1)\r\ngold_coins_img = load_image(\"snow/menu_coins.png\", color_key=-1)\r\nmenu_clocks_img = load_image(\"snow/menu_clocks.png\", color_key=-1)\r\n\r\nrunning_authors = False\r\nrunning_mario_res = False\r\nrunning_houses = True\r\nrunning_mario_game = False\r\nrunning_back = False\r\nrunning_mario_menu = False\r\n\r\n\r\nclass Particle(pygame.sprite.Sprite):\r\n    \"\"\"Класс для системы частиц(звездочек)\"\"\"\r\n    fire = [load_image(\"star.png\", color_key=-1)]\r\n    for scale in (10, 15, 25):\r\n        fire.append(pygame.transform.scale(fire[0], (scale, scale)))\r\n\r\n    def __init__(self, pos, dx, dy):\r\n        super().__init__(star_group)\r\n        self.image = random.choice(self.fire)\r\n        self.rect = self.image.get_rect()\r\n        self.velocity = [dx, dy]\r\n        self.rect.x, self.rect.y = pos\r\n        self.gravity = 0.1\r\n\r\n    def update(self):\r\n        self.velocity[1] += self.gravity\r\n        self.rect.x += self.velocity[0]\r\n        self.rect.y += self.velocity[1]\r\n        if not self.rect.colliderect(screen_rect):\r\n            self.kill()\r\n\r\n\r\ndef create_particles(position):\r\n    \"\"\"Функция для создания объектов класса частиц (звездочек)\"\"\"\r\n    numbers = range(-6, 5)\r\n    for _ in range(20):\r\n        Particle(position, random.choice(numbers), random.choice(numbers))\r\n\r\n\r\ndef draw_res_text(screen):\r\n    font = pygame.font.Font('data/final/seguisbi.ttf', 28)\r\n    text = font.render('WINNERS SCORE', True, pygame.Color('black'))\r\n    screen.blit(text, (SCREEN_WIDTH // 2 - text.get_width() // 2, 15))\r\n    # Результаты игры Марио\r\n    with open('data/mario/res_mario.txt', encoding=\"utf8\") as file:\r\n        text = file.readlines()\r\n    text_mario = clean_text(text)\r\n    text_coord = 25\r\n    for line in text_mario:\r\n        text = font.render(line, True, pygame.Color('white'))\r\n        text_x = 410 - text.get_width()\r\n        text_y = text_coord + text.get_height() + 10\r\n        text_coord = text_y\r\n        screen.blit(text, (text_x, text_y))\r\n\r\n    # Результаты игры Forrest\r\n    with open('data/BlackForrest/res_forrest.txt', encoding=\"utf8\") as file:\r\n        text_forrest = clean_text(file.readlines())\r\n    text_coord = 25\r\n    for line in text_forrest:\r\n        text = font.render(line, True, pygame.Color('white'))\r\n        text_x = 190 - text.get_width()\r\n        text_y = text_coord + text.get_height() + 10\r\n        text_coord = text_y\r\n        screen.blit(text, (text_x, text_y))\r\n\r\n    # Результаты игры Snow\r\n    with open('data/snow/res_snow.txt', encoding=\"utf8\") as file:\r\n        text_snow = clean_text(file.readlines())\r\n    text_coord = 25\r\n    for line in text_snow:\r\n        text = font.render(line, True, pygame.Color('white'))\r\n        text_x = 620 - text.get_width()\r\n        text_y = text_coord + text.get_height() + 10\r\n        text_coord = text_y\r\n        screen.blit(text, (text_x, text_y))\r\n\r\n\r\nclass Houses(pygame.sprite.Sprite):\r\n    house_1_small = load_image(\"start/house_1_small.png\", color_key=-1)\r\n    house_1_big = load_image(\"start/house_1_big.png\", color_key=-1)\r\n    house_2_small = load_image(\"start/house_2_small.png\", color_key=-1)\r\n    house_2_big = load_image(\"start/house_2_big.png\", color_key=-1)\r\n    house_3_small = load_image(\"start/house_3_small.png\", color_key=-1)\r\n    house_3_big = load_image(\"start/house_3_big.png\", color_key=-1)\r\n    exit_small = load_image(\"start/exit_small.png\", color_key=-1)\r\n    exit_big = load_image(\"start/exit_big.png\", color_key=-1)\r\n    res_small = load_image(\"start/res_small.png\", color_key=-1)\r\n    res_big = load_image(\"start/res_big.png\", color_key=-1)\r\n\r\n    def __init__(self, x, y, group, name):\r\n        super().__init__(group)\r\n        if name == 'exit':\r\n            self.image = Houses.exit_small\r\n        elif name == 'house_1':\r\n            self.image = Houses.house_1_small\r\n        elif name == 'house_2':\r\n            self.image = Houses.house_2_small\r\n        elif name == 'house_3':\r\n            self.image = Houses.house_3_small\r\n        elif name == 'res':\r\n            self.image = Houses.res_small\r\n        self.name = name\r\n        self.rect = self.image.get_rect()\r\n        self.pos = [x, y]\r\n        self.rect.x = x\r\n        self.rect.y = y\r\n\r\n    def update(self, *args):\r\n        if args and args[-1] == 1 and self.rect.collidepoint(args[0].get_pos()):\r\n            terminate()\r\n        if args and self.rect.collidepoint(args[0].get_pos()):\r\n            if self.name == 'exit':\r\n                self.image = Houses.exit_big\r\n            elif self.name == 'house_1':\r\n                self.image = Houses.house_1_big\r\n            elif self.name == 'house_2':\r\n                self.image = Houses.house_2_big\r\n            elif self.name == 'house_3':\r\n                self.image = Houses.house_3_big\r\n            elif self.name == 'res':\r\n                self.image = Houses.res_big\r\n            self.rect.x = self.pos[0] - 4\r\n            self.rect.y = self.pos[1] - 3\r\n        else:\r\n            if self.name == 'exit':\r\n                self.image = Houses.exit_small\r\n            elif self.name == 'house_1':\r\n                self.image = Houses.house_1_small\r\n            elif self.name == 'house_2':\r\n                self.image = Houses.house_2_small\r\n            elif self.name == 'house_3':\r\n                self.image = Houses.house_3_small\r\n            elif self.name == 'res':\r\n                self.image = Houses.res_small\r\n            self.rect.x = self.pos[0]\r\n            self.rect.y = self.pos[1]\r\n\r\n    def check_push(self, *args):\r\n        if args and self.rect.collidepoint(args[0].get_pos()):\r\n            return self.name\r\n\r\n\r\nHouses(11, 85, houses, 'house_1')\r\nHouses(147, 130, houses, 'house_2')\r\nHouses(425, 132, houses, 'house_3')\r\nHouses(9, 307, houses, 'exit')\r\nHouses(140, 55, houses, 'res')\r\n\r\nFPS = 80\r\nonGround = False\r\ntile_images = {\r\n    'exit': load_image('mario/new_level.png', color_key=-1),\r\n    'menu': load_image('mario/menu.png'),\r\n    'menu_coins': load_image(\"mario/menu_coins.png\", color_key=-1),\r\n    'menu_clocks': load_image(\"mario/menu_clocks.png\", color_key=-1),\r\n    'menu_door': load_image(\"mario/block.png\", color_key=-1),\r\n    'dirt': load_image(\"mario/dirt.png\"),\r\n    'grass': load_image(\"mario/grass.png\", color_key=-1),\r\n    'gru_wall': load_image(\"mario/gru_wall.png\", color_key=-1),\r\n    'snow': load_image(\"mario/snow.png\", color_key=-1)\r\n}\r\nplayer_image = load_image('mario/mario.png', color_key=-1)\r\nstart_img = pygame.transform.scale(load_image('mario/start_button.png'), (148, 68))\r\nbg = pygame.transform.scale(load_image('mario/mario (1).jpg'), (WIDTH, HEIGHT))\r\n\r\n# back_img = pygame.transform.scale(load_image('mario/back_img.png', color_key=-1), (86, 41))\r\n\r\ntile_size = tile_width = tile_height = 50\r\nlevel_completed = True\r\ncur_level = 8\r\nscore_coins = 0\r\nscore_time = 0\r\nlevels = ['mario/levels/level_1.txt', 'mario/levels/level_2.txt',\r\n          'mario/levels/level_3.txt', 'mario/levels/level_4.txt',\r\n          'mario/levels/level_5.txt', 'mario/levels/level_6.txt',\r\n          'mario/levels/level_7.txt', 'mario/levels/level_8.txt',\r\n          'mario/levels/level_9.txt']\r\nmusic = ['data/mario/music/portal.mp3', 'data/mario/music/field.mp3',\r\n         'data/mario/music/peace.mp3', 'data/mario/music/peace.mp3',\r\n         'data/mario/music/peace.mp3', 'data/mario/music/castle.mp3',\r\n         'data/mario/music/forest.mp3', 'data/mario/music/win.mp3',\r\n         'data/mario/music/peace.mp3']\r\nf_lvl = [load_image('mario/start_mario.jpg'), load_image('mario/second_peyzaj.jpg'),\r\n         load_image('mario/third_peizaj.jpg'),\r\n         load_image('mario/desert.png'), load_image('mario/fon_4.png'),\r\n         load_image('mario/far_castle.jpeg'), load_image('mario/black_forrest.jpg'),\r\n         load_image('mario/gru.png'), load_image('mario/last_fon.jpg')]  # словарь фонов для уровней\r\nn_lvl = ['Портал в лесу', 'Луг деревни Атрейдес', 'Лечебница Аркрайт',\r\n         'Пустыня Сахара', 'Зимние приключения', 'Проход через горы',\r\n         'Темный лес', 'Злой волшебник', 'Замок принцессы']  # Названия для уровней\r\nmax_level = len(levels)\r\nNEW_BEST = 'Вы попадаете в таблицу лидеров!'\r\n\r\n\r\ndef draw_mini_text(text, color, pos):\r\n    \"\"\"Рисование текста маленького размера для меню (марио)\"\"\"\r\n    font = pygame.font.Font(None, 30)\r\n    x, y = pos\r\n    text = font.render(text, True, color)\r\n    screen.blit(text, (x - text.get_width() // 2, y - text.get_height() // 2))\r\n\r\n\r\ndef generate_level(level):\r\n    new_player, x, y = None, None, None\r\n    list_with_walls = list()\r\n    list_with_walls.clear()\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            if level[y][x] == '.':\r\n                pass\r\n            elif level[y][x] == 'M':\r\n                til = Tile('menu', x, y)\r\n                tile = (til.image, til.rect)\r\n                list_with_walls.append(tile)\r\n            elif level[y][x] == '#':\r\n                wall = Wall(x, y, 'wall')\r\n                tile = (wall.image, wall.rect)\r\n                list_with_walls.append(tile)\r\n            elif level[y][x] == '9':\r\n                wall = Wall(x, y, 'dirt')\r\n                tile = (wall.image, wall.rect)\r\n                list_with_walls.append(tile)\r\n            elif level[y][x] == '8':\r\n                wall = Wall(x, y, 'gru_wall')\r\n                tile = (wall.image, wall.rect)\r\n                list_with_walls.append(tile)\r\n            elif level[y][x] == '5':\r\n                wall = Wall(x, y, 'snow')\r\n                tile = (wall.image, wall.rect)\r\n                list_with_walls.append(tile)\r\n            elif level[y][x] == '@':\r\n                new_player = Player(x, y)\r\n                level[y][x] = \".\"\r\n            elif level[y][x] == '2':\r\n                Exit(x, y)\r\n            elif level[y][x] == 'P':\r\n                Princess(x, y)\r\n            elif level[y][x] == '*':\r\n                AnimatedSprite(load_image(\"mario/menu_coins.png\", color_key=-1), 3, 2,\r\n                               tile_size * x + tile_size // 4, tile_size * y + tile_size // 4, coins_group, 9)\r\n    return new_player, x, y, list_with_walls\r\n\r\n\r\ndef menu_mario_game():\r\n    global running_mario_menu, running_mario_game, running_houses\r\n    pygame.display.set_caption('Mario: Multiverse')  # Название приложения\r\n    pygame.mixer.music.load(\"data/mario/music/honor-and-sword-main.mp3\")\r\n    pygame.mixer.music.play()\r\n    sound_btn = pygame.mixer.Sound(\"data/BlackForrest/button (2).mp3\")\r\n    pygame.mouse.set_visible(True)\r\n    start_btn = Button(SCREEN_WIDTH // 2 - start_img.get_width() // 2,\r\n                       SCREEN_HEIGHT // 2 - start_img.get_height() // 2, start_img)\r\n    go_back = Button(10, 10, back_img)\r\n    while running_mario_menu:\r\n        screen.blit(bg, (0, 0))\r\n        start_btn.update()\r\n        go_back.update()\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n\r\n        if start_btn.clicked:\r\n            sound_btn.play()\r\n            pygame.mixer.music.stop()\r\n            running_mario_game = True\r\n            running_mario_menu = False\r\n        if go_back.clicked:\r\n            pygame.mixer.music.stop()\r\n            sound_btn.play()\r\n            running_mario_menu = False\r\n            running_houses = True\r\n\r\n        pygame.display.flip()\r\n\r\n\r\nclass Tile(Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(sprite_group)\r\n        self.image = tile_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x, tile_height * pos_y)\r\n\r\n\r\nclass Wall(Sprite):\r\n    def __init__(self, pos_x, pos_y, name):\r\n        super().__init__(sprite_group)\r\n        if name == 'wall':\r\n            self.image = load_image(f'mario/box{random.choice(range(1, 4))}.png')\r\n        else:\r\n            self.image = tile_images[name]\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x, tile_height * pos_y)\r\n        self.add(wall_group)\r\n\r\n\r\nclass Player(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(hero_group)\r\n        self.image = player_image\r\n        self.index = 0\r\n        self.counter = 0\r\n\r\n        self.width = self.image.get_width()\r\n        self.height = self.image.get_height()\r\n\r\n        self.gravity = 0\r\n        self.notOnGround = True\r\n        self.jumped = False\r\n        self.direction = 0\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x + 15, tile_height * pos_y + 5)\r\n        self.start = tile_width * pos_x + 15, tile_height * pos_y + 5\r\n        self.pos = (pos_x, pos_y)\r\n        self.died = False\r\n\r\n    def update(self):\r\n        global onGround, level_completed\r\n        move_x = 0\r\n        move_y = 0\r\n\r\n        moving = 4\r\n\r\n        if not hero.died:\r\n            key = pygame.key.get_pressed()\r\n            if key[pygame.K_UP] and not self.jumped and not self.notOnGround:\r\n                self.gravity = -17\r\n                self.jumped = True\r\n            if not key[pygame.K_UP]:\r\n                self.jumped = False\r\n            if key[pygame.K_LEFT]:\r\n                move_x -= moving\r\n                self.counter += 1\r\n                self.direction = -1\r\n            if key[pygame.K_RIGHT]:\r\n                move_x += moving\r\n                self.counter += 1\r\n                self.direction = 1\r\n            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:\r\n                self.counter = 0\r\n                self.index = 0\r\n            if self.rect.x >= WIDTH:\r\n                self.rect = self.image.get_rect().move(self.rect.x % WIDTH, self.rect.y)\r\n            if self.rect.x <= 0:\r\n                self.rect = self.image.get_rect().move(WIDTH, self.rect.y)\r\n            if self.rect.y >= HEIGHT:\r\n                self.rect = self.image.get_rect().move(self.start)\r\n            self.gravity += 1\r\n            if self.gravity > 10:\r\n                self.gravity = 10\r\n            move_y += self.gravity\r\n\r\n            self.notOnGround = True\r\n\r\n            for tile in lst:\r\n                if tile[1].colliderect(self.rect.x + move_x, self.rect.y, self.width, self.height):\r\n                    move_x = 0\r\n\r\n                if tile[1].colliderect(self.rect.x, self.rect.y + move_y, self.width, self.height):\r\n                    if self.gravity < 0:\r\n                        move_y = tile[1].bottom - self.rect.top\r\n                        self.gravity = 0\r\n\r\n                    elif self.gravity >= 0:\r\n                        move_y = tile[1].top - self.rect.bottom\r\n                        self.gravity = 0\r\n                        self.notOnGround = False\r\n\r\n            if pygame.sprite.spritecollide(self, exit_group, False):\r\n                level_completed = True\r\n\r\n            self.rect.x += move_x\r\n            self.rect.y += move_y\r\n\r\n        screen.blit(self.image, self.rect)\r\n\r\n\r\nclass Exit(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(exit_group)\r\n        self.image = tile_images['exit']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n\r\n\r\nclass Princess(Sprite):\r\n    princess_l = load_image('mario/princess_l.png', color_key=-1)\r\n    princess_r = load_image(\"mario/princess_r.png\", color_key=-1)\r\n\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(princess_group)\r\n        self.lst = [Princess.princess_l, Princess.princess_r]\r\n        self.image = Princess.princess_l\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n        self.count = 0\r\n\r\n    def update(self):\r\n        if self.count % 109 == 0:\r\n            if self.count % 2 == 0:\r\n                self.image = self.lst[0]\r\n            else:\r\n                self.image = self.lst[1]\r\n        self.count += 1\r\n\r\n\r\ndef res_of_play():\r\n    global score_time, score_coins, lst, cur_level, level_completed, \\\r\n        running_mario_res, running_houses, running_authors\r\n    pygame.mouse.set_visible(True)\r\n    if not hero.died:\r\n        for i in range(-300, 310, 50):\r\n            create_particles((WIDTH // 2 + i, 0))\r\n        _ = AnimatedSprite(load_image(\"snow/coins.png\", color_key=-1), 3, 2, 155, 212, res_group, 5)\r\n        _ = AnimatedSprite(load_image(\"snow/clocks.png\", color_key=-1), 7, 2, 148, 130, res_group, 5)\r\n        time = f'{str(score_time // 3600).rjust(2, \"0\")}:{str(score_time % 3600 // 60).rjust(2, \"0\")}'\r\n        intro_text = [\"Вы Выиграли. Принцесса спасена!\", \"\", f'Время: {time}',\r\n                      '', f\"Монеты: {score_coins}\",\r\n                      f\"{NEW_BEST if check_new_table('mario', int(score_coins), time) else ''}\"]\r\n        fon = pygame.transform.scale(load_image('mario/final_mario.png'), screen_size)\r\n        screen.blit(fon, (0, 0))\r\n        draw_text(intro_text)\r\n    else:\r\n        intro_text = ['']\r\n        fon = load_image('mario/gameover.png', color_key=-1)\r\n    exit_btn = Button(SCREEN_WIDTH / 2 - 117 / 2, 299,\r\n                      pygame.transform.scale(load_image(\"BlackForrest/exit_btn.png\", color_key=-1), (117, 49)))\r\n\r\n    while running_mario_res:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            elif event.type == pygame.KEYDOWN or \\\r\n                    event.type == pygame.MOUSEBUTTONDOWN:\r\n                create_particles(pygame.mouse.get_pos())\r\n        screen.blit(fon, (0, 0))\r\n        draw_text(intro_text, color=pygame.Color('black'))\r\n        res_group.draw(screen)\r\n        res_group.update()\r\n        star_group.update()\r\n        star_group.draw(screen)\r\n        exit_btn.update()\r\n        if exit_btn.clicked:\r\n            cur_level = 0\r\n            score_coins = 0\r\n            score_time = 0\r\n            level_completed = True\r\n            lst.clear()\r\n            running_houses = True\r\n            running_mario_res = False\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n\r\n\r\nsprite_group = SpriteGroup()\r\nwall_group = SpriteGroup()\r\nhero_group = SpriteGroup()\r\nexit_group = SpriteGroup()\r\nprincess_group = SpriteGroup()\r\ncoins_group = SpriteGroup()\r\nres_group = SpriteGroup()\r\nmenu_mario_group = SpriteGroup()\r\n# анимация панели меню\r\ncoins = AnimatedSprite(tile_images['menu_coins'], 3, 2, 5, 0, menu_mario_group, 9)\r\nclocks = AnimatedSprite(tile_images['menu_clocks'], 7, 2, tile_size * 1.9, 0, menu_mario_group, 6)\r\ndoor = AnimatedSprite(tile_images['menu_door'], 1, 1, tile_size * 11.5, 0, menu_mario_group, 6)\r\n\r\n\r\ndef open_level(level):\r\n    global hero, max_x, max_y, level_map, lst\r\n\r\n    sprite_group.empty()\r\n    hero_group.empty()\r\n    exit_group.empty()\r\n    princess_group.empty()\r\n    coins_group.empty()\r\n    wall_group.empty()\r\n    pygame.mixer.music.load(music[level - 1])\r\n    pygame.mixer.music.play()\r\n    level_map = load_level(levels[level - 1])\r\n    hero, max_x, max_y, lst = generate_level(level_map)\r\n\r\n\r\nlevel_map = load_level(levels[cur_level])\r\nhero, max_x, max_y, lst = generate_level(level_map)\r\n\r\n\r\ndef game_mario():\r\n    global score_time, level_completed, cur_level, score_coins, lst, \\\r\n        running_mario_game, running_mario_res\r\n    while running_mario_game:\r\n        score_time += 1\r\n        if level_completed:\r\n            pygame.mixer.music.stop()\r\n            cur_level += 1\r\n            open_level(cur_level)\r\n            level_completed = False\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running_mario_game = False\r\n                terminate()\r\n        else:\r\n            global onGround\r\n            onGround = False\r\n\r\n        fon = pygame.transform.scale(f_lvl[cur_level - 1], (WIDTH, HEIGHT))  # картинка\r\n        screen.blit(fon, (0, 0))\r\n        sprite_group.draw(screen)\r\n        wall_group.draw(screen)\r\n        hero_group.draw(screen)\r\n        exit_group.draw(screen)\r\n        princess_group.draw(screen)\r\n        coins_group.draw(screen)\r\n        coins_group.update()\r\n        hero.update()\r\n        princess_group.update()\r\n        clock.tick(FPS)\r\n        # Меню:\r\n        draw_mini_text(f'X {score_coins}', (255, 255, 255), (tile_size + 5, 15))  # монетки\r\n        time = f'{str(score_time // 3600).rjust(2, \"0\")}:{str(score_time % 3600 // 60).rjust(2, \"0\")}'\r\n        draw_mini_text(f'  {time}', (255, 255, 255), (tile_size * 3, 15))\r\n        draw_mini_text(f'LEVEL {cur_level}: {n_lvl[cur_level - 1]}', (255, 255, 255), (tile_size * 7, 15))\r\n        draw_mini_text(f'X {cur_level - 1}', (255, 255, 255), (WIDTH - tile_size // 2, 15))\r\n        menu_mario_group.draw(screen)\r\n        menu_mario_group.update()\r\n        if pygame.sprite.groupcollide(hero_group, coins_group, False, True):\r\n            sound1 = pygame.mixer.Sound(\"data/mario/music/coin..mp3\")\r\n            sound1.play()\r\n            score_coins += 1\r\n        if pygame.sprite.groupcollide(hero_group, exit_group, False, False):\r\n            level_completed = True\r\n        if pygame.sprite.groupcollide(hero_group, princess_group, False, False):\r\n            pygame.mixer.music.stop()\r\n            running_mario_res = True\r\n            running_mario_game = False\r\n        pygame.display.flip()\r\n    return\r\n\r\n\r\ndef start_progect_screen():\r\n    \"\"\"Функция вызова(отображения) стартового экрана\"\"\"\r\n    global running_houses, running_mario_menu\r\n    fon = pygame.transform.scale(load_image('start/start.png'), (WIDTH, HEIGHT))  # стартовая картинка\r\n    pressed = False\r\n    while running_houses:\r\n        pygame.display.set_caption('PyPurble Game Studio')  # Название приложения\r\n        pygame.display.set_icon(load_image(\"icon.ico\"))  # Иконка приложения\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                pressed = True\r\n            if event.type == pygame.MOUSEBUTTONUP:\r\n                if pressed:\r\n                    lst = [house.check_push(pygame.mouse) for house in houses]\r\n                    if 'exit' in lst:\r\n                        terminate()\r\n                    elif 'house_3' in lst:\r\n                        main_gameplay_snow()\r\n                    elif 'house_2' in lst:\r\n                        running_houses = False\r\n                        running_mario_menu = True\r\n                    elif 'house_1' in lst:\r\n                        menu_forrest_game()\r\n                    elif 'res' in lst:\r\n                        res_game_screen()\r\n\r\n            if event.type == pygame.MOUSEMOTION and pygame.mouse.get_focused():\r\n                houses.update(pygame.mouse)\r\n        screen.blit(fon, (0, 0))\r\n        houses.draw(screen)\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n    return\r\n\r\n\r\ndef res_game_screen():\r\n    running = True\r\n    fon = pygame.transform.scale(load_image('final/bg.png'), (WIDTH, HEIGHT))\r\n    go_back = Button(10, 5, back_img)\r\n    for i in range(-300, 310, 50):\r\n        create_particles((SCREEN_WIDTH // 2 + i, 0))\r\n    text_coord = 80\r\n    for _ in range(3):\r\n        coins = AnimatedSprite(gold_coins_img, 3, 2, 2, text_coord, menu_group, 9)\r\n        coins = AnimatedSprite(gold_coins_img, 3, 2, 238, text_coord, menu_group, 9)\r\n        coins = AnimatedSprite(gold_coins_img, 3, 2, 438, text_coord, menu_group, 9)\r\n        clocks = AnimatedSprite(menu_clocks_img, 7, 2, 110, text_coord, menu_group, 6)\r\n        clocks = AnimatedSprite(menu_clocks_img, 7, 2, 335, text_coord, menu_group, 6)\r\n        clocks = AnimatedSprite(menu_clocks_img, 7, 2, 540, text_coord, menu_group, 6)\r\n        text_coord += 50\r\n\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT or (event.type == pygame.K_RETURN and event.key == pygame.K_ESCAPE):\r\n                running = False\r\n                terminate()\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                create_particles(pygame.mouse.get_pos())\r\n                pass\r\n        screen.blit(fon, (0, 0))\r\n        draw_res_text(screen)\r\n        menu_group.draw(screen)\r\n        menu_group.update()\r\n        star_group.update()\r\n        star_group.draw(screen)\r\n        go_back.update()\r\n        if go_back.clicked:\r\n            running = False\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n    return\r\n\r\n\r\ndef main_mario_gameplay_snow():\r\n    \"\"\"Функция для навигации по игре(возврат в главное меню и тд)\"\"\"\r\n    global running_back, running_mario_menu, running_mario_game, running_mario_res, running_authors, running_houses\r\n    running_back = False\r\n    running_houses = True\r\n    while not running_back:\r\n        if running_houses:\r\n            start_progect_screen()\r\n        if running_mario_menu:\r\n            menu_mario_game()\r\n        if running_mario_game:\r\n            game_mario()\r\n        if running_mario_res:\r\n            res_of_play()\r\n        if running_authors:\r\n            running_authors = False\r\n            final_game_screen()\r\n\r\n        if running_back:\r\n            break\r\n    return\r\n\r\n\r\nif __name__ == '__main__':\r\n    main_mario_gameplay_snow()\r\n\r\n# pip freeze > requirements.txt\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ main.py	(date 1642769781244)
@@ -14,7 +14,7 @@
 star_group = pygame.sprite.Group()
 menu_group = pygame.sprite.Group()
 
-back_img = load_image('snow/back_img.png', color_key=-1)
+back_img = load_image('mario/back_img.png', color_key=-1)
 gold_coins_img = load_image("snow/menu_coins.png", color_key=-1)
 menu_clocks_img = load_image("snow/menu_clocks.png", color_key=-1)
 
@@ -176,7 +176,9 @@
     'dirt': load_image("mario/dirt.png"),
     'grass': load_image("mario/grass.png", color_key=-1),
     'gru_wall': load_image("mario/gru_wall.png", color_key=-1),
-    'snow': load_image("mario/snow.png", color_key=-1)
+    'snow': load_image("mario/snow.png", color_key=-1),
+    'flower': load_image("mario/flower_3.png", color_key=-1),
+    'kaktus': load_image("mario/cactus.png", color_key=-1)
 }
 player_image = load_image('mario/mario.png', color_key=-1)
 start_img = pygame.transform.scale(load_image('mario/start_button.png'), (148, 68))
@@ -186,27 +188,28 @@
 
 tile_size = tile_width = tile_height = 50
 level_completed = True
-cur_level = 8
+cur_level = 0
 score_coins = 0
 score_time = 0
 levels = ['mario/levels/level_1.txt', 'mario/levels/level_2.txt',
           'mario/levels/level_3.txt', 'mario/levels/level_4.txt',
           'mario/levels/level_5.txt', 'mario/levels/level_6.txt',
           'mario/levels/level_7.txt', 'mario/levels/level_8.txt',
-          'mario/levels/level_9.txt']
+          'mario/levels/level_10.txt', 'mario/levels/level_9.txt']
 music = ['data/mario/music/portal.mp3', 'data/mario/music/field.mp3',
          'data/mario/music/peace.mp3', 'data/mario/music/peace.mp3',
          'data/mario/music/peace.mp3', 'data/mario/music/castle.mp3',
          'data/mario/music/forest.mp3', 'data/mario/music/win.mp3',
-         'data/mario/music/peace.mp3']
+         'data/mario/music/peace.mp3', 'data/mario/music/peace.mp3']
 f_lvl = [load_image('mario/start_mario.jpg'), load_image('mario/second_peyzaj.jpg'),
          load_image('mario/third_peizaj.jpg'),
          load_image('mario/desert.png'), load_image('mario/fon_4.png'),
          load_image('mario/far_castle.jpeg'), load_image('mario/black_forrest.jpg'),
-         load_image('mario/gru.png'), load_image('mario/last_fon.jpg')]  # словарь фонов для уровней
+         load_image('mario/gru.png'), load_image('mario/fon_10.png'),
+         load_image('mario/last_fon.jpg')]  # словарь фонов для уровней
 n_lvl = ['Портал в лесу', 'Луг деревни Атрейдес', 'Лечебница Аркрайт',
          'Пустыня Сахара', 'Зимние приключения', 'Проход через горы',
-         'Темный лес', 'Злой волшебник', 'Замок принцессы']  # Названия для уровней
+         'Темный лес', 'Злой волшебник', 'Подходим к замку', "Замок принцессы"]  # Названия для уровней
 max_level = len(levels)
 NEW_BEST = 'Вы попадаете в таблицу лидеров!'
 
@@ -225,14 +228,16 @@
     list_with_walls.clear()
     for y in range(len(level)):
         for x in range(len(level[y])):
-            if level[y][x] == '.':
-                pass
-            elif level[y][x] == 'M':
+            if level[y][x] == 'M':
                 til = Tile('menu', x, y)
                 tile = (til.image, til.rect)
                 list_with_walls.append(tile)
             elif level[y][x] == '#':
                 wall = Wall(x, y, 'wall')
+                tile = (wall.image, wall.rect)
+                list_with_walls.append(tile)
+            elif level[y][x] == 'H':
+                wall = Wall(x, y, 'grass')
                 tile = (wall.image, wall.rect)
                 list_with_walls.append(tile)
             elif level[y][x] == '9':
@@ -252,6 +257,10 @@
                 level[y][x] = "."
             elif level[y][x] == '2':
                 Exit(x, y)
+            elif level[y][x] == 'F':
+                BackGround('flower', x, y)
+            elif level[y][x] == 'C':
+                BackGround('kaktus', x, y)
             elif level[y][x] == 'P':
                 Princess(x, y)
             elif level[y][x] == '*':
@@ -400,6 +409,14 @@
         self.image = tile_images['exit']
         self.rect = self.image.get_rect()
         self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)
+
+
+class BackGround(Sprite):
+    def __init__(self, name, pos_x, pos_y):
+        super().__init__(exit_group)
+        self.image = tile_images[name]
+        self.rect = self.image.get_rect()
+        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)
 
 
 class Princess(Sprite):
