Index: Game_Mary.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom final_screen import final_game_screen\r\nfrom main_functions import *\r\nfrom pygame import mixer\r\n\r\npygame.mixer.pre_init()\r\nmixer.init()\r\npygame.init()\r\nSCREEN_WIDTH, SCREEN_HEIGHT = screen_size = (645, 400)\r\nscreen_rect = (0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)\r\ntile_size = 50\r\nscreen = pygame.display.set_mode(screen_size)\r\nclock = pygame.time.Clock()\r\nfps = 60\r\n# Состояние игры\r\nscore_time = 0\r\nscore_coins = 0\r\nscore_buckets = 0\r\n\r\nrunning_authors = False\r\nrunning_res = False\r\nrunning_menu = True\r\nrunning_game = False\r\nrunning_back = False\r\nNEW_BEST = 'Вы попадаете в таблицу лидеров!'\r\n\r\ntile_images = {\r\n    'box': load_image('snow/box.png'),\r\n    'empty': load_image('snow/ice.png'),\r\n    'fire': load_image('snow/fire.png', color_key=-1),\r\n    'exit': load_image('snow/new_level.png', color_key=-1),\r\n    'flag': load_image('snow/flag.png', color_key=-1),\r\n    'coin': load_image('snow/coin.png', color_key=-1),\r\n    'bucket': load_image('snow/bucket.png', color_key=-1),\r\n}\r\nplayer_image = load_image('snow/snowman.png', color_key=-1)\r\nplayer_image_up = load_image('snow/snowman_up.png', color_key=-1)\r\nplayer_image_down = load_image('snow/snowman_down.png', color_key=-1)\r\nplayer_image_left = load_image('snow/snowman_left.png', color_key=-1)\r\n\r\nexit_btn = pygame.transform.scale(load_image(\"BlackForrest/exit_btn.png\", color_key=-1), (117, 49))\r\nstart_img = load_image('snow/btn_start.png')\r\nbg = load_image('snow/bg.png')\r\nback_img = load_image('snow/back_img.png', color_key=-1)\r\nrules_img = load_image('snow/rules_img.png', color_key=-1)\r\n\r\nlevels = ['snow/level_1.txt', 'snow/level_2.txt', 'snow/level_3.txt',\r\n          'snow/level_4.txt', 'snow/level_5.txt']\r\nrandom.shuffle(levels)\r\nlevels.append('snow/level_6.txt')\r\nn_lvl = {'snow/level_1.txt': 'Начало', 'snow/level_2.txt': 'Так держать',\r\n         'snow/level_4.txt': 'Продолжай!', 'snow/level_3.txt': 'Бонусный уровень',\r\n         'snow/level_5.txt': 'Black forrest!', 'snow/level_6.txt': 'Финал!'}  # Названия для уровней\r\nmax_level = len(levels)\r\nwhite = (255, 255, 255)\r\n\r\nmotion = 'STOP'  # по умолчанию — стоим, флаг для непрерывного движения\r\n\r\n# подключение музыки\r\nmain_music_loud = 0.5\r\nsignal_sound_loud = 1\r\ncoin_sound = pygame.mixer.Sound('data/snow/music/coin.mp3')\r\ncoin_sound.set_volume(signal_sound_loud)\r\nbuckets_sound = pygame.mixer.Sound('data/snow/music/bucket.mp3')\r\nbuckets_sound.set_volume(signal_sound_loud)\r\nstop_fire_sound = pygame.mixer.Sound('data/snow/music/stop_fire.mp3')\r\nstop_fire_sound.set_volume(signal_sound_loud)\r\nnew_level_sound = pygame.mixer.Sound('data/snow/music/new_level.mp3')\r\nnew_level_sound.set_volume(signal_sound_loud)\r\ngame_over_sound = pygame.mixer.Sound('data/snow/music/game_over.mp3')\r\ngame_over_sound.set_volume(signal_sound_loud)\r\n\r\n\r\ndef generate_level(level):\r\n    new_player, x, y = None, None, None\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            if level[y][x] == '.':  # пусто\r\n                Tile('empty', x, y)\r\n            elif level[y][x] == '#':  # стена\r\n                Tile('box', x, y)\r\n            elif level[y][x] == '@':  # игрок\r\n                Tile('empty', x, y)\r\n                new_player = Player(x, y)\r\n                level[y][x] = \".\"\r\n            elif level[y][x] == '%':  # огонь\r\n                Tile('empty', x, y)\r\n                _ = Fire(x, y)\r\n            elif level[y][x] == '*':  # coins\r\n                Tile('empty', x, y)\r\n                _ = Coins(x, y)\r\n            elif level[y][x] == '2':  # exit_next_level\r\n                Tile('empty', x, y)\r\n                _ = Exit(x, y)\r\n            elif level[y][x] == '5':  # final_level_exit\r\n                Tile('empty', x, y)\r\n                _ = Finish(x, y)\r\n            elif level[y][x] == '0':  # ведро с водой\r\n                Tile('empty', x, y)\r\n                _ = Bucket(x, y)\r\n    return new_player, x, y\r\n\r\n\r\ndef open_level(level):\r\n    global camera, player, level_x, level_y, level_map\r\n\r\n    all_sprites.empty()\r\n    player_group.empty()\r\n    tiles_group.empty()\r\n    box_group.empty()\r\n    fire_group.empty()\r\n    coins_group.empty()\r\n    exit_group.empty()\r\n    finish_group.empty()\r\n    star_group.empty()\r\n    res_group.empty()\r\n    bucket_group.empty()\r\n\r\n    level_map = load_level(levels[level])\r\n    player, level_x, level_y = generate_level(level_map)\r\n    camera = Camera((level_x, level_y))\r\n\r\n\r\nclass Tile(Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(all_sprites)\r\n        self.image = tile_images[tile_type]\r\n        self.rect = self.image.get_rect().move(tile_size * pos_x, tile_size * pos_y)\r\n\r\n        if tile_type == 'box':\r\n            self.add(box_group, tiles_group, all_sprites)\r\n        else:\r\n            self.add(tiles_group, all_sprites)\r\n\r\n\r\nclass Player(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(player_group)\r\n        self.image = player_image\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n        self.died = False\r\n        self.pos = [pos_x, pos_y]\r\n        self.add(player_group, all_sprites)\r\n\r\n    def move(self, direction, x, y):\r\n        speed = tile_size\r\n        if direction == 'up':\r\n            self.rect = self.rect.move(0, -speed)\r\n            self.pos[1] = y\r\n            self.image = player_image_up\r\n        elif direction == 'down':\r\n            self.rect = self.rect.move(0, +speed)\r\n            self.pos[1] = y\r\n            self.image = player_image_down\r\n        elif direction == 'left':\r\n            self.rect = self.rect.move(-speed, 0)\r\n            self.pos[0] = x\r\n            self.image = player_image_left\r\n        elif direction == 'right':\r\n            self.rect = self.rect.move(+speed, 0)\r\n            self.pos[0] = x\r\n            self.image = player_image\r\n\r\n\r\nclass Fire(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(fire_group)\r\n        self.image = tile_images['fire']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n\r\n        self.add(fire_group, all_sprites)\r\n\r\n\r\nclass Bucket(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(bucket_group)\r\n        self.image = tile_images['bucket']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n\r\n        self.add(bucket_group, all_sprites)\r\n\r\n\r\nclass Finish(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(finish_group)\r\n        self.image = tile_images['flag']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n        self.add(finish_group, all_sprites)\r\n\r\n\r\nclass Exit(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(exit_group)\r\n        self.image = tile_images['exit']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n        self.add(exit_group, all_sprites)\r\n\r\n\r\nclass Coins(Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(coins_group)\r\n        self.image = tile_images['coin']\r\n        self.rect = self.image.get_rect()\r\n        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)\r\n        self.add(coins_group, all_sprites)\r\n\r\n\r\nclass Camera:\r\n    def __init__(self, field_size):\r\n        self.dx = 0\r\n        self.dy = 0\r\n        self.field_size = field_size\r\n\r\n    def apply(self, obj):\r\n        obj.rect.x += self.dx\r\n\r\n        if obj.rect.x < -obj.rect.width:\r\n            obj.rect.x += (self.field_size[0] + 1) * obj.rect.width\r\n\r\n        if obj.rect.x >= (self.field_size[0]) * obj.rect.width:\r\n            obj.rect.x += -obj.rect.width * (1 + self.field_size[0])\r\n        obj.rect.y += self.dy\r\n\r\n        if obj.rect.y < -obj.rect.height:\r\n            obj.rect.y += (self.field_size[1] + 1) * obj.rect.height\r\n        if obj.rect.y >= (self.field_size[1]) * obj.rect.height:\r\n            obj.rect.y += -obj.rect.height * (1 + self.field_size[1])\r\n\r\n    def update(self, target):\r\n        self.dx = -(target.rect.x + target.rect.w // 2 - SCREEN_WIDTH // 2)\r\n        self.dy = -(target.rect.y + target.rect.h // 2 - SCREEN_HEIGHT // 2)\r\n\r\n\r\ndef menu_snowman_game():\r\n    global running_back, running_menu, running_game\r\n    pygame.display.set_caption('Snow_Snow')\r\n    pygame.display.set_icon(load_image(\"icon.ico\"))  # Иконка приложения\r\n    pygame.mouse.set_visible(True)\r\n    start_btn = Button(SCREEN_WIDTH // 2 - start_img.get_width() // 2,\r\n                       SCREEN_HEIGHT // 2 - start_img.get_height() - 20, start_img)\r\n    go_back = Button(10, 10, back_img)\r\n    rules = Button(SCREEN_WIDTH // 2 - rules_img.get_width() // 2,\r\n                   SCREEN_HEIGHT // 2 + 20, rules_img)\r\n    while running_menu:\r\n        fon = pygame.transform.scale(bg, screen_size)\r\n        screen.blit(fon, (0, 0))\r\n        start_btn.update()\r\n        go_back.update()\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n\r\n        if start_btn.clicked:\r\n            running_game = True\r\n            running_menu = False\r\n        if rules.clicked:\r\n            print('rules')\r\n        if go_back.clicked:\r\n            running_back = True\r\n            running_menu = False\r\n\r\n        pygame.display.flip()\r\n    return\r\n\r\n\r\nclass Particle(Sprite):\r\n    \"\"\"Класс для системы частиц(звездочек)\"\"\"\r\n    fire = [load_image(\"star.png\", color_key=-1)]\r\n    for scale in (5, 10, 20):\r\n        fire.append(pygame.transform.scale(fire[0], (scale, scale)))\r\n\r\n    def __init__(self, pos, dx, dy):\r\n        super().__init__(star_group)\r\n        self.image = random.choice(self.fire)\r\n        self.rect = self.image.get_rect()\r\n        self.velocity = [dx, dy]\r\n        self.rect.x, self.rect.y = pos\r\n        self.gravity = 0.25\r\n\r\n    def update(self):\r\n        self.velocity[1] += self.gravity\r\n        self.rect.x += self.velocity[0]\r\n        self.rect.y += self.velocity[1]\r\n        if not self.rect.colliderect(screen_rect):\r\n            self.kill()\r\n\r\n\r\ndef create_particles(position):\r\n    \"\"\"Функция для создания объектов класса частиц (звездочек)\"\"\"\r\n    numbers = range(-5, 6)\r\n    for _ in range(20):\r\n        Particle(position, random.choice(numbers), random.choice(numbers))\r\n\r\n\r\ndef res_of_play():\r\n    global running_menu, score_time, score_coins, cur_level, \\\r\n        level_completed, exit_btn, NEW_BEST, running_res, running_back\r\n    pygame.mouse.set_visible(True)\r\n    exit_btn = Button(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, exit_btn)\r\n\r\n    if not player.died:\r\n        for i in range(-300, 310, 50):\r\n            create_particles((SCREEN_WIDTH // 2 + i, 0))\r\n        _ = AnimatedSprite(load_image(\"snow/coins.png\", color_key=-1), 3, 2, 155, 212, res_group, 5)\r\n        _ = AnimatedSprite(load_image(\"snow/clocks.png\", color_key=-1), 7, 2, 148, 130, res_group, 5)\r\n        time = f'{str(score_time // 3600).rjust(2, \"0\")}:{str(score_time % 3600 // 60).rjust(2, \"0\")}'\r\n        intro_text = [\"Вы Выиграли!\", \"\", f'Время: {time}', '', f\"Монеты: {score_coins}\",\r\n                      f\"{NEW_BEST if check_new_table('snow', int(score_coins), time) else ''}\"]\r\n        fon = pygame.transform.scale(load_image('final.png'), screen_size)\r\n        screen.blit(fon, (0, 0))\r\n        draw_text(intro_text)\r\n    else:\r\n        intro_text = ['']\r\n        fon = load_image('snow/gameover.png', color_key=-1)\r\n\r\n    while True:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            elif event.type == pygame.KEYDOWN or \\\r\n                    event.type == pygame.MOUSEBUTTONDOWN:\r\n                final_game_screen()\r\n        screen.blit(fon, (0, 0))\r\n        draw_text(intro_text)\r\n\r\n        star_group.update()\r\n        star_group.draw(screen)\r\n        res_group.draw(screen)\r\n        res_group.update()\r\n        exit_btn.update()\r\n        if exit_btn.clicked:\r\n            cur_level = 0\r\n            score_coins = 0\r\n            score_time = 0\r\n            level_completed = False\r\n            running_res = False\r\n            running_back = True\r\n            running_menu = True\r\n            return\r\n        pygame.display.flip()\r\n        clock.tick(fps)\r\n\r\n\r\nall_sprites = pygame.sprite.Group()\r\nplayer_group = pygame.sprite.Group()\r\ntiles_group = pygame.sprite.Group()\r\nbox_group = pygame.sprite.Group()\r\nfire_group = pygame.sprite.Group()\r\ncoins_group = pygame.sprite.Group()\r\nexit_group = pygame.sprite.Group()\r\nfinish_group = pygame.sprite.Group()\r\nstar_group = pygame.sprite.Group()\r\nres_group = pygame.sprite.Group()\r\nbucket_group = pygame.sprite.Group()\r\nmenu_group = pygame.sprite.Group()\r\n# меню\r\ncoins = AnimatedSprite(load_image(\"snow/menu_coins.png\", color_key=-1), 3, 2, 5, 0, menu_group, 9)\r\nclocks = AnimatedSprite(load_image(\"snow/menu_clocks.png\", color_key=-1), 7, 2, tile_size + 12, 0, menu_group, 6)\r\nwaters = AnimatedSprite(load_image(\"snow/menu_water.png\", color_key=-1), 3, 2, tile_size * 2.9, 0, menu_group, 8)\r\ndoors = AnimatedSprite(load_image(\"snow/menu_doors.png\", color_key=-1), 2, 1, SCREEN_WIDTH - tile_size * 1.3, 0,\r\n                       menu_group,\r\n                       35)\r\n\r\nlevel_completed = False\r\n\r\ncur_level = 0\r\nlevel_map = load_level(levels[cur_level])\r\nplayer, level_x, level_y = generate_level(level_map)\r\ncamera = Camera((level_x, level_y))\r\n\r\n\r\ndef move(hero, direction):\r\n    x, y = hero.pos\r\n    green_move = [\".\", '2', '5', '*', '0', '%']\r\n    if direction == \"up\":\r\n        if y > 0 and level_map[y - 1][x] in green_move:\r\n            hero.move(direction, x, y - 1)\r\n        elif y == 0 and level_map[y - 1][x] in green_move:\r\n            hero.move(direction, x, level_y)\r\n    elif direction == \"down\":\r\n        if y < level_y and level_map[y + 1][x] in green_move:\r\n            hero.move(direction, x, y + 1)\r\n        elif y == level_y and level_map[0][x] in green_move:\r\n            hero.move(direction, x, 0)\r\n    elif direction == \"left\":\r\n        if x > 0 and level_map[y][x - 1] in green_move:\r\n            hero.move(direction, x - 1, y)\r\n        elif x == 0 and level_map[y][level_x] in green_move:\r\n            hero.move(direction, level_x, y)\r\n    elif direction == \"right\":\r\n        if x < level_x and level_map[y][x + 1] in green_move:\r\n            hero.move(direction, x + 1, y)\r\n        elif x == level_x and level_map[y][0] in green_move:\r\n            hero.move(direction, 0, y)\r\n\r\n\r\ndef game_snowman():\r\n    global score_time, score_buckets, score_coins, level_completed, cur_level, motion\r\n    global running_back, running_game, running_authors, running_res\r\n    pygame.display.set_caption('Snow_Snow')\r\n    pygame.display.set_icon(load_image(\"icon.ico\"))  # Иконка приложения\r\n    while running_game:\r\n        score_time += 1\r\n        if level_completed:\r\n            cur_level += 1\r\n            open_level(cur_level)\r\n            new_level_sound.play()\r\n            level_completed = False\r\n        for event in pygame.event.get():\r\n            keys = pygame.key.get_pressed()\r\n            if keys[pygame.K_UP] or keys[pygame.K_DOWN] or \\\r\n                    keys[pygame.K_LEFT] or keys[pygame.K_RIGHT]:\r\n                if keys[pygame.K_UP]:\r\n                    motion = 'up'\r\n                elif keys[pygame.K_DOWN]:\r\n                    motion = 'down'\r\n                elif keys[pygame.K_LEFT]:\r\n                    motion = 'left'\r\n                elif keys[pygame.K_RIGHT]:\r\n                    motion = 'right'\r\n                move(player, motion)\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n        camera.update(player)\r\n        for sprite in all_sprites:\r\n            camera.apply(sprite)\r\n        screen.fill(pygame.Color(255, 100, 100))\r\n        tiles_group.draw(screen)\r\n        fire_group.draw(screen)\r\n        coins_group.draw(screen)\r\n        finish_group.draw(screen)\r\n        exit_group.draw(screen)\r\n        player_group.draw(screen)\r\n        bucket_group.draw(screen)\r\n\r\n        # Меню:\r\n        pygame.draw.rect(screen, (181, 146, 146), (0, 0, SCREEN_WIDTH, tile_size // 2))\r\n        draw_mini_text(f'X {score_coins}', white, (tile_size - 10, 12))\r\n        time = f'{str(score_time // 3600).rjust(2, \"0\")}:{str(score_time % 3600 // 60).rjust(2, \"0\")}'\r\n        draw_mini_text(f'  {time}', white, (tile_size * 2, 12))\r\n        draw_mini_text(f'X {score_buckets}', white, (tile_size * 3.75, 12))\r\n        text = n_lvl[levels[cur_level]]\r\n        draw_mini_text(f'LEVEL {cur_level + 1}: {text}', white, (tile_size * 7, 12))\r\n        draw_mini_text(f'X {cur_level}', white, (SCREEN_WIDTH - tile_size // 2, 12))\r\n        menu_group.draw(screen)\r\n        menu_group.update()\r\n\r\n        if pygame.sprite.groupcollide(player_group, coins_group, False, True):\r\n            coin_sound.play()\r\n            score_coins += 1\r\n        if pygame.sprite.groupcollide(player_group, bucket_group, False, True):\r\n            buckets_sound.play()\r\n            score_buckets += 1\r\n        if pygame.sprite.groupcollide(player_group, exit_group, False, False):\r\n            level_completed = True\r\n        if pygame.sprite.groupcollide(player_group, finish_group, False, False):\r\n            running_game = False\r\n            running_res = True\r\n        if pygame.sprite.groupcollide(player_group, fire_group, False, True):\r\n            if score_buckets < 1:\r\n                game_over_sound.play()\r\n                player.died = True\r\n                running_game = False\r\n            else:\r\n                stop_fire_sound.play()\r\n                score_buckets -= 1\r\n\r\n        if player.died:\r\n            running_game = False\r\n            running_res = True\r\n        pygame.display.flip()\r\n        clock.tick(fps)\r\n    return\r\n\r\n\r\ndef main_gameplay_snow():\r\n    \"\"\"Функция для навигации по игре(возврат в главное меню и тд)\"\"\"\r\n    global running_back, running_menu, running_game, running_res, running_authors\r\n    running_back = False\r\n    running_menu = True\r\n    while not running_back:\r\n        print(running_back, running_menu, running_game, running_res, running_authors)\r\n        if running_menu:\r\n            menu_snowman_game()\r\n        if running_game:\r\n            game_snowman()\r\n        if running_res:\r\n            res_of_play()\r\n        if running_authors:\r\n            running_authors = False\r\n            final_game_screen()\r\n\r\n        if running_back:\r\n            break\r\n    return\r\n\r\n\r\nif __name__ == '__main__':\r\n    game_snowman()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Game_Mary.py	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ Game_Mary.py	(date 1642768025600)
@@ -32,6 +32,7 @@
     'flag': load_image('snow/flag.png', color_key=-1),
     'coin': load_image('snow/coin.png', color_key=-1),
     'bucket': load_image('snow/bucket.png', color_key=-1),
+    'stone': load_image('snow/stones.png')
 }
 player_image = load_image('snow/snowman.png', color_key=-1)
 player_image_up = load_image('snow/snowman_up.png', color_key=-1)
@@ -79,6 +80,8 @@
                 Tile('empty', x, y)
             elif level[y][x] == '#':  # стена
                 Tile('box', x, y)
+            elif level[y][x] == 'B':  # стена
+                Tile('box1', x, y)
             elif level[y][x] == '@':  # игрок
                 Tile('empty', x, y)
                 new_player = Player(x, y)
@@ -86,6 +89,9 @@
             elif level[y][x] == '%':  # огонь
                 Tile('empty', x, y)
                 _ = Fire(x, y)
+            elif level[y][x] == 'V':  # камни
+                Tile('empty', x, y)
+                _ = Stones(x, y)
             elif level[y][x] == '*':  # coins
                 Tile('empty', x, y)
                 _ = Coins(x, y)
@@ -173,6 +179,16 @@
         self.add(fire_group, all_sprites)
 
 
+class Stones(Sprite):
+    def __init__(self, pos_x, pos_y):
+        super().__init__(stones_group)
+        self.image = tile_images['stone']
+        self.rect = self.image.get_rect()
+        self.rect = self.rect.move(tile_size * pos_x, tile_size * pos_y)
+
+        self.add(stones_group, all_sprites)
+
+
 class Bucket(Sprite):
     def __init__(self, pos_x, pos_y):
         super().__init__(bucket_group)
@@ -302,7 +318,7 @@
     global running_menu, score_time, score_coins, cur_level, \
         level_completed, exit_btn, NEW_BEST, running_res, running_back
     pygame.mouse.set_visible(True)
-    exit_btn = Button(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, exit_btn)
+    exit_btn = Button(SCREEN_WIDTH / 2, 350, exit_btn)
 
     if not player.died:
         for i in range(-300, 310, 50):
@@ -358,6 +374,7 @@
 star_group = pygame.sprite.Group()
 res_group = pygame.sprite.Group()
 bucket_group = pygame.sprite.Group()
+stones_group = pygame.sprite.Group()
 menu_group = pygame.sprite.Group()
 # меню
 coins = AnimatedSprite(load_image("snow/menu_coins.png", color_key=-1), 3, 2, 5, 0, menu_group, 9)
@@ -438,6 +455,7 @@
         exit_group.draw(screen)
         player_group.draw(screen)
         bucket_group.draw(screen)
+        stones_group.draw(screen)
 
         # Меню:
         pygame.draw.rect(screen, (181, 146, 146), (0, 0, SCREEN_WIDTH, tile_size // 2))
@@ -502,4 +520,4 @@
 
 
 if __name__ == '__main__':
-    game_snowman()
+    main_gameplay_snow()
Index: data/snow/level_1.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#.##2#....*\r\n#..#.#.#..#.\r\n#..%.###.*#.\r\n.......#..#.\r\n#..*...#..#.\r\n###....%..#.\r\n.....#....#.\r\n.##....**@#\r\n.#%##.####..\r\n.#.....##...\r\n.#..####.......\r\n.......\r\n......
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- data/snow/level_1.txt	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ data/snow/level_1.txt	(date 1642767540169)
@@ -1,5 +1,5 @@
 #.##2#....*
-#..#.#.#..#.
+#..#.#.#..#.VV
 #..%.###.*#.
 .......#..#.
 #..*...#..#.
@@ -7,7 +7,7 @@
 .....#....#.
 .##....**@#
 .#%##.####..
-.#.....##...
-.#..####.......
-.......
+.#.....##..VV.
+.#..####....
+...***...
 ......
\ No newline at end of file
Index: data/snow/level_4.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>......0.........\r\n..............\r\n.................\r\n.....######\r\n.....##2%\r\n###########%%%\r\n.....\r\n....@.\r\n...........\r\n........
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- data/snow/level_4.txt	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ data/snow/level_4.txt	(date 1642767078303)
@@ -1,10 +1,10 @@
 ......0.........
-..............
+..VVVVVVVVVVV...
 .................
-.....######
-.....##2%
-###########%%%
-.....
-....@.
-...........
-........
\ No newline at end of file
+.....######.....
+.....##2%.......
+##%%%%%######%%%
+.............
+....@........
+.............
+.......0.......
\ No newline at end of file
Index: data/snow/level_6.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#.##.#....**#.%%#..%%%\r\n#..#.#.#..#...%%##..*\r\n#....#....*#....##*%%\r\n....*..#..#...###%...\r\n#..*#..#..#..%%%#**%##\r\n#.#%5%.%..#.....##%%..\r\n.%%%%%%%.%%%.%%%..*##\r\n.......%*#%%#####...%.##\r\n.#%#####.##.....##\r\n.#.....##...###\r\n.#..#......###...@0\r\n....####...**%%%###..%.###\r\n...##..**..%%####...%%..**\r\n..######**..##*##...%%%##...\r\n.%.#.*#*#*#*%%%%%..*###....
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- data/snow/level_6.txt	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ data/snow/level_6.txt	(date 1642767040026)
@@ -1,9 +1,9 @@
 #.##.#....**#.%%#..%%%
 #..#.#.#..#...%%##..*
-#....#....*#....##*%%
-....*..#..#...###%...
+#.00.#..0.*#....##*%%
+....*..#..#...###%0..
 #..*#..#..#..%%%#**%##
-#.#%5%.%..#.....##%%..
+#.#%5%.%0.#....0##%%0.
 .%%%%%%%.%%%.%%%..*##
 .......%*#%%#####...%.##
 .#%#####.##.....##
@@ -12,4 +12,4 @@
 ....####...**%%%###..%.###
 ...##..**..%%####...%%..**
 ..######**..##*##...%%%##...
-.%.#.*#*#*#*%%%%%..*###....
\ No newline at end of file
+.%.#0*#*#*#*%%%%%..*###....
\ No newline at end of file
Index: data/mario/levels/level_4.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MMMMMMMMMMMMM\r\n..*....**...\r\n..2...999....\r\n..9........*\r\n.999.....99\r\n.*..9..9.*99\r\n..@...9......\r\n999.9999999.9
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- data/mario/levels/level_4.txt	(revision 5f647d990aed61b759dd63b82a6d49cd1d1a635e)
+++ data/mario/levels/level_4.txt	(date 1642769808888)
@@ -1,8 +1,8 @@
 MMMMMMMMMMMMM
 ..*....**...
 ..2...999....
-..9........*
+.C9........*
 .999.....99
 .*..9..9.*99
-..@...9......
+..@...9.C....
 999.9999999.9
\ No newline at end of file
